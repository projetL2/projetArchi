\documentclass{report}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage{setspace}
\usepackage{listings} 
\usepackage{hyperref}
\usepackage{amssymb}
\usepackage{graphicx}

\begin{document}
\lstset{language=C}
\title{Compte-rendu du projet \\Architecture des ordinateurs}
\author{Gaëtan CHAMBRES
\and
Chrystelle PETUREAU}
\date{05/05/2015}

\maketitle

\tableofcontents

\chapter{Exercice 1:De la place dans les opcodes}
\section{Question 1:Libérer I-ALU}
Le but de cette question est de faire en sorte que toutes les opérations de type "iXX" soit confondu avec leur consoeurs de même type. Pour cela, nous avons renommer l'identifiant de l'opérateur I-ALUI en I-FREE1. On définit maintenant I-ALUI comme la même opération que I-ALU avec la ligne de commande suivante ( fichier: isa.h, lignes 29 et 33):
\begin{lstlisting}[frame=single]
#define I_ALUI I_ALU
\end{lstlisting}
De ce fait dans le fichier isa.c, on commente la partie du case: (fichier: isa.c de la ligne 925 à la ligne 951)
\begin{lstlisting}[frame=single]
case I_ALUI:
\end{lstlisting}
pour ne pas avoir d'erreur lors de la compilation, vu que les opérateurs I-ALU et I-ALUI sont, maintenant, confondu.
\section{Question 2:Distinguer IOPL et OPL}
\subsection{Version séquentielle}
Pour permettre l'utilisation distingue de I-OPL et OPL, nous avons éffectué les modifications suivantes dans les fichiers HCL:\\
Pour l'architecture seq, dans le ficher seq-std.hcl, aux lignes 129 et 130, nous avons ajouté ces deux lignes.
\begin{lstlisting}[frame=single]
icode in {OPL} && rA == RNONE : valC;
icode in { OPL } : valA;
\end{lstlisting}

Elles permettent de vérifier avant l'étage EXECUTE si le registre srcA de l'opération OPL vaut rA ou RNONE. Si le registre vaut RNONE, alors on lit la valeur de la constante valC, sinon on lit valA, le contenu de rA.\\
Nous avons alors testé,après recompilation, avec le code suivant:
\begin{lstlisting}[frame=single]

	.pos 0
	
	irmovl 5,%eax
	irmovl 5,%ebx
	iaddl 5,%eax
	iaddl 5,%ebx
	addl %ebx,%eax
	
	halt
	
\end{lstlisting}
Et nous avons obtenu le résultat suivant:
\begin{figure}[hbtp]
\caption{Etape 1}
\centering
\includegraphics[scale=0.2]{résultat_de_test/ex1_testOPL_seq/etape1.png}
\end{figure}
\begin{figure}[hbtp]
\caption{Etape 2 et 3}
\centering
\includegraphics[scale=0.2]{résultat_de_test/ex1_testOPL_seq/etape2-3.png}
\end{figure}
\begin{figure}[hbtp]
\caption{Etape 4 et 5}
\centering
\includegraphics[scale=0.2]{résultat_de_test/ex1_testOPL_seq/etape4-5.png}
\end{figure}
\begin{figure}[!h]
\caption{Etape 6}
\centering
\includegraphics[scale=0.2]{résultat_de_test/ex1_testOPL_seq/etape6.png}
\end{figure}
 \\
  \\
   \\
    \\
\subsection{Version pipeline}
Pour l'architecture pipelinée, nous avons ajouté les lignes suivantes (pipe-std.hcl, ligne 204), qui devrait permettre de faire la même vérification que pour la version séquentielle détaillée ci-dessus.
\begin{lstlisting}[frame=single]

E_icode in {OPL} && D_rA == RNONE : E_valC;
	E_icode in {OPL} : E_valA;
	
\end{lstlisting}
Mais lorsque nous testons le processeur avec le code suivant, qui est une version adaptée au pipeline du test utilisé précédemment:
\begin{lstlisting}[frame=single]
	.pos 0
	irmovl 5,%eax
	nop
	irmovl 5,%ebx
	nop
	iaddl 5,%eax
	nop
	iaddl 5,%ebx
	nop
	nop
	nop
	nop
	addl %ebx,%eax
	halt
\end{lstlisting}
les résultats ne sont pas corrects. Le surnombre d'opérateurs NOPE nous permet d'être sur que le problème ne vient pas de bulles manquantes. L'erreur se présente au moment de l'opération "addl" pour laquelle le processeur lit le contenu des deux registres, mais aussi une constante valC égale à 16 (en décimal). Puis à l'exécution, le processeur ajoute au registre B le contenu de cette constante plutôt que celui du registre A.\\
Nous n'avons pas su localiser ce problème et donc le résoudre, cependant voici nos résultats:
 \\
  \\
   \\
    \\
\begin{figure}[!h]
\caption{Etape 1}
\centering
\includegraphics[scale=0.2]{resultat_de_test/ex1_testOPL_pipe/Etape1.png}
\end{figure}
\begin{figure}[!h]
\caption{Etape 2}
\centering
\includegraphics[scale=0.2]{resultat_de_test/ex1_testOPL_pipe/Etape2.png}
\end{figure}
\begin{figure}[!h]
\caption{Etape 3 - erreur dans le résultat}
\centering
\includegraphics[scale=0.2]{resultat_de_test/ex1_testOPL_pipe/Etape3.png}
\end{figure}

\section{Question 3:}
\section{Partie bonus:}

\chapter{Exercice 2:}
On cherche à créer un pas à pas dans le fonctionnement du processeur.
\section{Version séquentielle:}
Dans le fichier seq-std.hcl, ligne 92, nous avons ajouté une instruction pour préciser pour quelles valeurs le processeur passera à l'instruction suivante.
\begin{lstlisting}[frame=single]
int instr-next-ifun=[
	1:-1;
	];
\end{lstlisting} 
Dans le fichier ssim.c à la ligne 375, nous avons ajouter le prototype de la fonction "gen-instr-next-ifun" qui "lit" le compteur d'instructions. On ajoute cette fonction à la ligne 667.
\begin{lstlisting}[frame=single]
if(gen_instr_next_ifun () != -1)
	ifun = gen_instr_next_ifun();
else
\end{lstlisting} 

Enfin à la ligne 772, on ajoute l'instruction:
\begin{lstlisting}[frame=single]
if (gen_instr_next_ifun() == -1){
	pc_in = gen_new_pc();
}
\end{lstlisting} 
Elle permet de calculer la nouvelle valeur du compteur ordinal.
\section{version pipe-line:}
Les modifications sont quasiment similaire à la version séquentielle.
Dans le fichier pipe-std.hcl, ligne 138, nous avons ajouté une instruction pour préciser pour quelles valeurs le processeur passera à l'instruction suivante.
\begin{lstlisting}[frame=single]
int instr-next-ifun=[
	1:-1;
	];
\end{lstlisting} 
Dans le fichier psim.c à la ligne 1327, nous avons ajouter le prototype de la fonction "gen-instr-next-ifun" qui "lit" le compteur d'instructions. On ajoute cette fonction à la ligne 1361.
\begin{lstlisting}[frame=single]
if(gen_instr_next_ifun () != -1)
	if_id_next->ifun = gen_instr_next_ifun();
	fetch_ok= TRUE;
else
	fetch_ok=get_byte_val(mem,valp, &instr);
\end{lstlisting} 

Enfin à la ligne 1388, on ajoute l'instruction:
\begin{lstlisting}[frame=single]
if (gen_instr_next_ifun() == -1){
	pc_next->pc=gen_new_F_predPC();
}
\end{lstlisting} 
Elle permet de calculer la nouvelle valeur du compteur ordinal.

\chapter{Exercice 3:}
\section{Question 1:}
\section{Question 2:}
\subsection{Instruction mul:}
\subsection{Instructions lods/stos/movs:}
\subsection{Instruction repstos:}
\section{Question 3:}
\section{Question 4:}

\end{document}