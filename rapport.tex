\documentclass{report}

\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage{setspace}
\usepackage{listings} 
\usepackage{hyperref}
\usepackage{graphicx}


\begin{document}
\lstset{language=C}
\title{Compte-rendu final du projet \\Architecture des ordinateurs}
\author{Gaëtan CHAMBRES
\and
Chrystelle PETUREAU}
\date{10/05/2015}
\maketitle

\section*{Exercice 1:}
\subsection*{Question 1:}
On nous demande de faire en sorte que toutes les opérations de type "iXX" soit confondu avec leur consoeurs. Pour cela, nous avons renommer l'identifiant de l'opérateur I-ALUI en I-FREE1 et en précisant qu'on défini maintenant I-ALUI comme la même chose que I-ALU avec la ligne(isa.h, ligne 29 et 33):
\begin{lstlisting}[frame=single]
#define I_ALUI I_ALU
\end{lstlisting}
De ce fait dans isa.c, on commente la partie (isa.c de la ligne 925 à la ligne 951)
\begin{lstlisting}[frame=single]
case I_ALUI:
\end{lstlisting}
pour ne pas avoir d'erreur lors de la compilation, vu que maintenant I-ALU et I-ALUI sont confondu.
\subsection*{Question 2:}
\subsection*{Version séquentielle}
Pour permettre l'utilisation de I-OPL et OPL, voici les modifications apportées dans les fichiers HCL:\\
Pour l'architecture seq, dans le ficher seq-std.hcl, aux lignes 129 et 130, nous avons ajouté ces deux lignes, qui permettent de vérifier avant l'étage EXECUTE si le registre srcA de l'opération OPL vaut rA ou RNONE. Si le registre vaut RNONE, alors on lit la valeur de la constante valC, sinon on lit valA, le contenu de rA.
\begin{lstlisting}[frame=single]
icode in {OPL} && rA == RNONE : valC;
icode in { OPL } : valA;
\end{lstlisting}

Nous avons alors testé,après recompilation, avec le code suivant:
\begin{lstlisting}[frame=single]

	.pos 0
	
	irmovl 5,%eax
	irmovl 5,%ebx
	iaddl 5,%eax
	iaddl 5,%ebx
	addl %ebx,%eax
	
	halt
	
\end{lstlisting}
Et nous avons obtenu le résultat suivant:
\begin{figure}[!h]
\caption{Etape 1}
\centering
\includegraphics[scale=0.2]{resultat_de_test/ex1_testOPL_seq/etape1.png}
\end{figure}
\begin{figure}[!h]
\caption{Etape 2 et 3}
\centering
\includegraphics[scale=0.2]{resultat_de_test/ex1_testOPL_seq/etape2-3.png}
\end{figure}
\begin{figure}[!h]
\caption{Etape 4 et 5}
\centering
\includegraphics[scale=0.2]{resultat_de_test/ex1_testOPL_seq/etape4-5.png}
\end{figure}
\begin{figure}[!h]
\caption{Etape 6}
\centering
\includegraphics[scale=0.2]{resultat_de_test/ex1_testOPL_seq/etape6.png}
\end{figure}
 \\
  \\
   \\
    \\
\subsection*{Version pipelinée}
Pour l'architecture pipelinée, nous avons ajouté les lignes suivantes (pipe-std.hcl, ligne 204), qui devrait permettre de faire la même vérification que pour la version séquentielle détaillée ci-dessus.
\begin{lstlisting}[frame=single]

E_icode in {OPL} && D_rA == RNONE : E_valC;
	E_icode in {OPL} : E_valA;
	
\end{lstlisting}
Mais lorsque nous testons le processeur avec le code suivant, qui est une version adaptée au pipeline du test utilisé précédemment:
\begin{lstlisting}[frame=single]
	.pos 0
	irmovl 5,%eax
	nop
	irmovl 5,%ebx
	nop
	iaddl 5,%eax
	nop
	iaddl 5,%ebx
	nop
	nop
	nop
	nop
	addl %ebx,%eax
	halt
\end{lstlisting}
les résultats ne sont pas corrects. Le surnombre d'opérateurs NOPE nous permet d'être sur que le problème ne vient pas de bulles manquantes. L'erreur se présente au moment de l'opération "addl" pour laquelle le processeur lit le contenu des deux registres, mais aussi une constante valC égale à 16 (en décimal). Puis à l'exécution, le processeur ajoute au registre B le contenu de cette constante plutôt que celui du registre A.\\
Nous n'avons pas su localiser ce problème et donc le résoudre, cependant voici nos résultats:
 \\
  \\
   \\
    \\
\begin{figure}[!h]
\caption{Etape 1}
\centering
\includegraphics[scale=0.2]{resultat_de_test/ex1_testOPL_pipe/Etape1.png}
\end{figure}
\begin{figure}[!h]
\caption{Etape 2}
\centering
\includegraphics[scale=0.2]{resultat_de_test/ex1_testOPL_pipe/Etape2.png}
\end{figure}
\begin{figure}[!h]
\caption{Etape 3 - erreur dans le résultat}
\centering
\includegraphics[scale=0.2]{resultat_de_test/ex1_testOPL_pipe/Etape3.png}
\end{figure}

\subsection*{Question 3:}
\subsection*{Partie bonus:}

\section*{Exercice 2:}
On cherche à créer un pas à pas dans le fonctionnement du processeur.
\subsection*{Version séquentielle:}
Dans le fichier seq-std.hcl, ligne 92, nous avons ajouté une instruction pour préciser pour quelles valeurs le processeur passera à l'instruction suivante.
\begin{lstlisting}[frame=single]
int instr-next-ifun=[
	1:-1;
	];
\end{lstlisting} 
Dans le fichier ssim.c à la ligne 375, nous avons ajouter le prototype de la fonction "gen-instr-next-ifun" qui "lit" le compteur d'instructions. On ajoute cette fonction à la ligne 667.
\begin{lstlisting}[frame=single]
if(gen_instr_next_ifun () != -1)
	ifun = gen_instr_next_ifun();
else
\end{lstlisting} 

Enfin à la ligne 772, on ajoute l'instruction:
\begin{lstlisting}[frame=single]
if (gen_instr_next_ifun() == -1){
	pc_in = gen_new_pc();
}
\end{lstlisting} 
Elle permet de calculer la nouvelle valeur du compteur ordinal.
\subsection*{version pipe-linée:}
Les modifications sont quasiment similaire à la version séquentielle.
Dans le fichier pipe-std.hcl, ligne 138, nous avons ajouté une instruction pour préciser pour quelles valeurs le processeur passera à l'instruction suivante.
\begin{lstlisting}[frame=single]
int instr-next-ifun=[
	1:-1;
	];
\end{lstlisting} 
Dans le fichier psim.c à la ligne 1327, nous avons ajouter le prototype de la fonction "gen-instr-next-ifun" qui "lit" le compteur d'instructions. On ajoute cette fonction à la ligne 1361.
\begin{lstlisting}[frame=single]
if(gen_instr_next_ifun () != -1)
	if_id_next->ifun = gen_instr_next_ifun();
	fetch_ok= TRUE;
else
	fetch_ok=get_byte_val(mem,valp, &instr);
\end{lstlisting} 

Enfin à la ligne 1388, on ajoute l'instruction:
\begin{lstlisting}[frame=single]
if (gen_instr_next_ifun() == -1){
	pc_next->pc=gen_new_F_predPC();
}
\end{lstlisting} 
Elle permet de calculer la nouvelle valeur du compteur ordinal.

\section*{Exercice 3:}
\subsection*{Question 1:}
\subsection*{Question 2:}
\subsection*{Instruction mul:}
\subsection*{Instructions lods/stos/movs:}
\subsection*{Instruction repstos:}
\subsection*{Question 3:}
\subsection*{Question 4:}

\end{document}